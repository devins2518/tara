\documentclass[10pt]{article}

\usepackage{amsmath}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{amssymb}

\newcommand{\alt}{~~|~~}
\newcommand{\comp}[1]{\llbracket #1 \rrbracket}

\newcommand{\inlinexp}[1]{
	{\footnotesize
			\[\begin{array}{l}
					#1
				\end{array}\]}}

\newcommand{\inlinexpa}[2]{
	{\footnotesize
			\[\begin{array}{#1}
					#2
				\end{array}\]}}

\newcommand{\infr} [3] [] {\infer[\textsc{#1}]{#3}{#2}}
\newcommand{\iand}        {\qquad}

\newcommand{\funct} [2] {#1\nobreak\rightarrow\nobreak#2}
\newcommand{\boolt}     {\mathtt{bool}}

\newcommand{\typeEnv}         {\Gamma}
\newcommand{\entails}         {\vdash}
\newcommand{\judgment}    [3] {#1 \entails #2 : #3}
\newcommand{\envent}      [2] {\judgment{\typeEnv}{#1}{#2}}
\newcommand{\extenvent}   [4] {\judgment{\typeEnv, #1 : #2}{#3}{#4}}
\newcommand{\envlookup}   [3] {\infr{#1(#2) = #3}{\judgment{#1}{#2}{#3}}}
\newcommand{\hyphen}          {\mbox{-}}

\newcommand{\letbind}  [2] {\mathsf{let}~\lbind{#1}{#2}}
\newcommand{\letbindp} [2] {\mathsf{let}~(\lbind{#1}{#2})}
\newcommand{\lbind}    [2] {#1=#2}
\newcommand{\letin}    [1] {\mathsf{in}~#1}

%% if
\newcommand{\ife}      [3] {\ifline{#1}~\thenline{#2}~\elseline{#3}}
\newcommand{\ifea}     [3] {\begin{array}{l}\ifline{#1}\\\thenline{#2}\\\elseline{#3}\end{array}}

\newcommand{\ifop}         {\mathsf{if}}
\newcommand{\ifline}   [1] {\ifop~ \mathsf{(}#1\mathsf{)}}
\newcommand{\thenline} [1] {\mathsf{then}~#1}
\newcommand{\elseline} [1] {\mathsf{else}~#1}

%% opers
\newcommand{\binopdef}     {\mathit{binop}}
\newcommand{\unopdef}      {\mathit{unop}}
\newcommand{\binope}   [2] {\binopdef~#1~#2}
\newcommand{\unope}    [1] {\unopdef~#1}

\newcommand{\andop}        {\mathsf{and}}
\newcommand{\orop}         {\mathsf{or}}
\newcommand{\notop}        {\mathsf{not}}
\newcommand{\ande}     [2] {\mathsf{and}~#1~#2}
\newcommand{\ore}      [2] {\mathsf{or}~#1~#2}
\newcommand{\note}     [1] {\mathsf{not}~#1}

\newcommand{\falsev}     {\mathsf{false}}
\newcommand{\truev}      {\mathsf{true}}

\setlength{\abovedisplayskip}{2pt}
\setlength{\belowdisplayskip}{2pt}

\begin{document}

\section{Language Definition}

Notes:
\begin{itemize}
	\item How to separate dataflow and control flow in a simple manner?
\end{itemize}

\[
	\begin{array}{rclrclrcl}
		p  & \in  & \verb|PORTS|                           & m & \in & \verb|MODULES| & x & \in & \verb|VARIABLES|  \\
		t  & \in  & \verb|TYPES|                           & e & \in & \verb|EXPRS|   & s & \in & \verb|STATEMENTS| \\
		op & \in  & \andop \alt \orop \alt \verb|&|        & b & \in & \verb|BLOCKS|  &   &     &                   \\
		   & \alt & \verb|\|| \alt \verb|^| \alt \verb|<|  &   &     &                &   &                         \\
		   & \alt & \verb|>| \alt \verb|<=| \alt \verb|>=| &   &     &                &   &                         \\
		   & \alt & \verb|==| \alt \verb|!=| \alt \verb|+| &   &     &                &   &                         \\
		   & \alt & \verb|-| \alt \verb|*|  \alt \verb|\|  &   &     &                &   &                         \\
	\end{array}
\]
\[
	\begin{array}{rcl}
		P   & :=   & (\verb|requires | e)^?\ (\verb|ensures | e)^?\                                                  \\
		t   & :=   & \verb|bool| \alt  (\verb|u| \alt \verb|i|)\overline{[0-9]} \alt \verb|sig|                      \\
		    & \alt & m \alt \verb|[|e\verb|]var|^?\ e \alt p \alt \verb|type|                                        \\
		e   & :=   & t \alt {e}\:\mathit{op}\:{e} \alt \mathit{op}\ {e} \alt {e}.{e} \alt {e}() \alt (e)             \\
		    & \alt & \&\verb|var|^? e \alt b \alt \verb|undefined| \alt \verb|true| \alt \verb|false| \alt x         \\
		    & \alt & e\verb|.*| \alt \verb|expect | e                                                                \\
		    & \alt & \ifline{e}\ e\ (\verb|else | e)^?                                                               \\
		p_f & :=   & id \verb|: &var|^? t                                                                            \\
		p   & :=   & \verb|port {| \overline{p_f} \verb|}|                                                           \\
		m   & :=   & \verb|module | P \verb| { | \overline{p_f}\ \overline{s}\ \overline{c} \verb| }|                \\
		x   & :=   & id                                                                                              \\
		s_p & :=   & pub                                                                                             \\
		s_q & :=   & \verb|var| \alt \verb|const|                                                                    \\
		s   & :=   & s_p^?\ s_q\ x (\verb|: | t)^? \verb| = | e \verb|;|                                             \\
		    & \alt & x = e;                                                                                          \\
		    & \alt & \ifline{e}\ \{\overline{s}\}\ (\verb|else | (\ifline{e})^?\ \{\overline{s}\})^?                 \\
		c   & :=   & s_p^?\ \verb|comb | id \verb|(|\overline{id:\ p} \verb|) | t\ P \verb| {| \overline{s} \verb|}| \\
		b   & :=   & (id\verb|:|)^? \verb|{ | \overline{s} \verb| }|                                                 \\
		%% TODO: for loops with unrolling
	\end{array}
\]

\section{Drafting}

\begin{verbatim}
const Adder = module() {
    const P = port {
        a: &u1,
        b: &u1,
        out: &var u1,
        carry: &var u1,
    };

    comb add(p: P) 
        ensures p.out = p.a +% p.b;
    {
        p.out = p.a ^ p.b; 
        p.carry = p.a & p.b;
    }
};
comb adder(a: &u1, b: &u1, out: &var u1, carry: &var u1)
    ensures carry = a +% b;
{
    out = a ^ b;
    carry = a & b;
}
comb main() {
    const mod = CoolMod();
    const a = 1;
    const b = 1;
    var out = undefined;
    var carry = undefined;
    mod.add(.{ .a = a, .b = b, .out = out, .carry = carry });
}
\end{verbatim}

Version with ports at module level:
\begin{itemize}
	\item Need to resolve multidriven ports across combs
\end{itemize}

\begin{verbatim}
const CoolMod = module(p: CoolMod.P) {
    const P = port {
        a: &u1,
        b: &u1,
        out: &var u1,
        carry: &var u1,
    };

    comb add() {
        p.out = p.a ^ p.b; 
        p.carry = p.a & p.b;
    }
};
\end{verbatim}

\begin{itemize}
	\item It came to me in a dream
\end{itemize}

\begin{verbatim}
const Sync0 = module(clk: clock, nrst: reset) {
    prev: [2]u1 = @reg(.{ clk, nrst }),

    comb sync(sync: Sync, async_in: &u1) u1 {
        sync.prev.next = &.{sync.prev[0], async_in.*};

        return sync.prev[1];
    }
};
comb top(clk: clock, nrst: reset) {
    const sync = Sync(clk, nrst);
    const async_in = ...;
    const sync_out = sync.sync(&async_in);
    ...
}
\end{verbatim}

\begin{itemize}
	\item Registers and other signals can live at module level to allow for any comb to access them,
	      however, only one comb can drive each register (should this be done at comb call level?)
	\item Language "constructs" (i.e. stage blocks) can create implicitly registers/memories,
	      however expressions should not be able to implicitly.
\end{itemize}

\begin{itemize}
	\item Modules have shared resources as fields created lazily as used by called combs, empty box if created and no combs called
	\item Comb invocation provides dataflow to signals within module
\end{itemize}

\begin{verbatim}
const Sync2FF = module {
    clk: clock,
    nrst: reset,

    pub comb sync(self: &Sync2FF, async_in: &sig) u1 {
        const prev: u2 = @reg(self.clk, self.nrst);

        prev.next = &.{prev[0], async_in};
        return prev[1];
    }
};
// Alternatively, the module can be collapsed into a single comb
// which stores the previous state
comb sync(clk: &clock, nrst: &reset, async_in: &sig) u1 {
    const prev: u2 = @reg(clk, nrst);

    prev.next = &.{prev[0], async_in};
    return prev[1];
}
comb top(async_in: &sig) void {
    const clk = @clockInit();
    const nrst = @resetInit(.negedge);
    const sync = Sync2FF{ .clk = clk, .nrst = nrst };
    const sync_out = sync.sync(&async_in);
}
\end{verbatim}

\begin{itemize}
	\item Structs can be used as pseudo-modules
	\item Function calls instantaneous and non-synthesizable but simulatable
\end{itemize}

\begin{verbatim}
const Sync2FF = struct {
    prev: u2,

    pub fn init(clk: clock, nrst: reset) Sync2FF {
        return .{ .prev = std.Reg.init(clk, nrst, 0b00) };
    }

    pub fn sync(self: Sync2FF, async_in: *sig) u1 {
        const ret = self.prev[1];
        self.prev.nextVal(&.{self.prev[0], async_in.*});
        return ret;
    }
};
comb top(asyn_in: &sig) void {
    const clk = @clockInit();
    const nrst = @resetInit(.negedge);
    const sync = Sync2FF.init(clk, nrst);
    const sync_out = sync.sync(&async_in);
}
\end{verbatim}

\begin{itemize}
	\item Testing
\end{itemize}

\begin{verbatim}
fn Unsigned(comptime len: u16) type {
    return @Int(.unsigned, len)
}
comb adder(
    comptime len: u16,
    a: Unsigned(len),
    b: Unsigned(len),
    carry_in: u1
) struct {
    sum: Unsigned(len),
    overflow u1,
} {
    ...
}

// Exhaustive dynamic testing
test adder {
    inline for (1..4) |adder_size| {
        // pseudo loop
        for (0..2^adder_size) |a| {
            for (0..2^adder_size) |b| {
                for (0..1) |carry| {
                    const out = adder(adder_size, a, b, carry);
                    const expected = @addWithOverflow(
                        a,
                        b + carry
                    );
                    try std.testing.expect(
                        out.sum,
                        expected.sum
                    );
                    try std.testing.expect(
                        out.overflow,
                        expected.overflow
                    );
                }
            }
        }
    }
}

// Static module level verification, done at compile time
// through Z3, symbolic execution, or such
comb adder(...) struct { ... } requires ... ensures 
    // Figures out some way to prove this
    ret.sum = a + b + carry_in and
    ret.overflow = (@as(Unsigned(len+1), a) + b + carry_in)>>len 
{
    ...
}

// Module level predicates can be used to provide invariates
const Mod = module ensures Mod.a != Mod.b {
    a: u2,
    b: u2,
    ...
};

// `expect` statements can be used to provide run-time checks
// for predicates
comb adder(...) u2 requires ... ensures ret == a + b {
    ...
    expect ret == a + b;
    return ret;
}
\end{verbatim}

\section{CPU Example (Taken from Spade)}

\begin{verbatim}
// Mandatory `delay(N)` attribute, used for API purposes,
// must match number of stages
// Stages ordered by declaration order
// How to ensure future stage reg uses are semantically valid?
pipe Cpu3Stage(clk: clock, nrst: reset, halt: &bool) delay(4) {
    const fetch = stage {
        const stall = decode.stall | halt;
        const pc_mod = Pc{ .clk = &clk, .nrst = &nrst };
        pub const pc = pc_mod.next(
            stall,
            execute.jump_target orelse pc_mod.now + 4
        );
    };
    const decode = stage {
        pub const insn = Insn.from(readMem(pc));
        pub const is_jump = insn.isJump();
        pub const stall = is_jump;
    };
    const execute = stage {
        const regs = Regfile(clk, nrst, memory.result);
        // Linear combs limit number of read ports for regfile.
        const op_a = regs.read0(&decode.insn.op_a);
        const op_b = regs.read1(&decode.insn.op_b);
        // How are combs tracked across stages?
        const jump_target ?u32 = if (decode.is_jump)
            decode.insn.jumpTarget()
        else
            null;
        const alu = Alu();
        pub const result = alu.result(op_a, op_b);
    };
    const writeback = stage {
        pub const result = switch (decode.insn.ty) {
            .add, .sub, .set => execute.alu_result,
            .jump => null,
        };
    };
};

const Insn = struct {
    ...,

    comb isJump(insn: &Insn) sig {
        ...
    }
    comb from(raw: &u32) Insn {
        const insn = ...decoding...;
        if (insn.isJump()) {
            return Noop;
        } else {
            return insn;
        }
    }
};

const Regfile = struct {
    ...,

    pub linear comb read0(regfile: Regfile, idx: u5) u32 {
        ...
    }
    pub linear comb read1(regfile: Regfile, idx: u5) u32 {
        ...
    }
}
\end{verbatim}

\section{Possible Lowering to Calyx}

\begin{verbatim}
const Adder = module { ... };

// Implements (m0 + m1) + (m2 + m3)
const Reducer = module {
    a0: Adder,
    a1: Adder,
    a2: Adder,

    pub comb reduce(
        self: Reducer,
        m0: u8,
        m1: u8,
        m2: u8,
        m3: u8
    ) u8 {
        const a0: u8 = @reg(.{.clk = clk, .rst = nrst});
        const a1: u8 = @reg(.{.clk = clk, .rst = nrst});
        const a2: u8 = @reg(.{.clk = clk, .rst = nrst});
        a0.next = self.a0.add(m0, m1);
        a1.next = self.a1.add(m2, m3);
        a2.next = self.a2.add(a0, a1);
        return a2.curr;
    }
};
\end{verbatim}

\section{Types}

\subsection{General}
Types will be first class values, allowing for simple polymorphism through function calls at compile
time. Synthesizable references use the \verb|&| syntax as an invalid reference to a net is not possible.
Nonsynthesizable references should use the \verb|*| syntax as invalid references to variables is possible
(i.e. pointer casts). Verilog conversion will attempt to track use of \verb|z| and \verb|x| (i.e.
net not always driven) for conversion into \verb|uN|. Use of these will probably be valid compile
error.

\subsection{Ports}
Ports are guaranteed-synthesizable constructs which map to wires. The only valid fields are net
references (\verb|&T|).

\subsection{References and Pointers}
References to nets use the \verb|&| syntax (\verb|&T|) as opposed to pointers to variables which use
the \verb|*| syntax (\verb|*T|). References are guaranteed to point to semantically valid variables.
In the case of references to non-synthesizable constructs, they are guaranteed to be semantically
valid (not assigned to using \verb|undefined|). There are a few rules for coercion and typing when using the
\verb|&| operator:

\begin{itemize}
	\item Use of the \verb|&| operator in a synthesizable context (comb, module, etc) creates a \verb|&T|.
	\item Use of the \verb|&| operator in a non-synthesizable context (fn) creates a \verb|*T|.
	\item A \verb|&T| can decay into a \verb|*T|.
	\item A \verb|*T| can be promoted to a \verb|&T| through the \verb|@strongRef()| builtin function.
	      \begin{enumerate}
		      \item The pointer will be checked to ensure it is properly aligned, and the use of undefined
		            will be tracked to ensure that all fields are semantically valid.
	      \end{enumerate}
\end{itemize}

Unlike pointers, references are not meant to be used for non-synthesizable use cases. This is
because \verb|&var T| is a read-illegal, write-once type. It can be thought of as a more restrictive
linear type in which reads are not legal. This is because \verb|&var T| type represents an output
port; it may cause combinatorial loops when read, and multiple writes simply cannot be synthesized.
Unlike pointers, references do not support the dereference (\verb|v.*|) operator and freely decay
into a \verb|T| when used.

\end{document}
